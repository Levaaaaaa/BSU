/*
	ДОБАВИТЬ СЖАТИЕ КООРДИНАТ Х!!!
	создадим массив compress_x, отсортируем, удалим повторяющиеся элементы
	переделать прочие массивы под сжатые координаты
	каждый раз, когда нужна координата, искать её в массиве дихотомией

	??? Вопрос: как сжатие координат экономит время? 
	Без него обращение к координате - константа O(1), с ним - O(log(n))
	Если он жертвует временем ради выигрыша в памяти, то зачем использовать, ведь память неограничена
*/

/*
	Ещё идеи: завести массив, в котором по индексу y будет сохранено количество деревьев с таким y
				Это пригодится для ускорения посещения всех деревьев с заданным y (y_max в частности)
				Также в max_delta_x не стоит учитывать деревья, которые лежат ниже y_min
				Для поиска таких деревьев на каждой итерации также может пригодится массив y_counts
*/
/*
* 5.04.24
* 
	Ошибки WA устранены. Нужно ускорить алгоритм. На данном этапе не проходит 11/24 тестов, все TLE
	Асимптотика на данном этапе: O((h + w) * n^2)
	Суть алгоритма:
		1. выставляем y_min на максимальное значение - h - 1
O(n)	2. в цикле: опускаем его по уникальным значениям y - O(n)
			для каждого фиксированного y_min:
	O(n)	2.1	удаляем деревья, координаты y которых меньше, чем y_min, т.к. они не мешают площадке, ограниченной y_min и y_max - 
					ВАЖНО: удаление деревьев временное, деревья лишь помечаются как удалённые и будут восстановлены для следующего y_min
			2.2	выставляем значение y_max на максимум - h
	O(h)	2.3	в цикле: опускаем y_max пока оно не совпадёт с заранее зафиксированным y_min - O(h)
				для каждой фиксированной пары y_min, y_max:
		O(w)	2.3.1 в цикле: обходим все деревья, координата y которых совпадает с y_max
						для каждого дерева:
						2.3.1.1 фиксируем координату х этого дерева
						2.3.1.2 проверяем, есть ли на площадке еще деревья с таким х
								если есть - уменьшаем их количество и переходим к следующему дереву
								иначе идём дальше
						2.3.1.3	на площадке больше нет деревьев с данным х. Нужно пересчитать max_delta_x, 
								т.к. между какими-то теперь соседними х расстояние увеличилось.
								Нужно найти правого и левого соседа по х удаляемого дерева
								будем идти от удаляемой вершины по списку list_x вправо и влево и проверять, удалены ли деревья, которые мы посещаем
								так идём до первого неудалённого справа и первого неудалённого слева
						O(w)	это цикл

						ЗАМЕЧАНИЕ: c одной стороны мы лишаем себя преимуществ связного списка не используя удаление, а лишь помечая деревья в булевом векторе
									но с другой стороны список ведь работает непосредственно с памятью и если мы удалим элемент списка по указателю,
									то изменится список в глобальной области видимости.
									Тогда мы не сможем его восстановить для другой итерации (при новом y_min)
								
						
						Нужно сделать:
							- убрать isDeleteTree, в main() завести копию list_x и восстанавливать на каждой итерации
							- добавить сжатие координат
*/

7.04.24, 16/24, TLE
	Добился небольшого ускорения, когда убрал isDeletedTree и начал напрямую удалять деревья из списка
	В таком случае вынужден восстанавливать список для каждого y_min
	Завёл резервную копию списка, по ней провожу восстановление на каждой итерации конструктором копирования
	Также вынужен обновлять массив nodes, чтобы он содержал актуальные указатели. Это в цикле.
	

	Без сжатия координат работает быстрее. Непонятно, зачем оно надо
